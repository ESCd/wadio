@using Wadio.App.UI.Infrastructure
@implements IAsyncDisposable

@inject DOMInterop Dom
@inject MarqueeInterop Interop

<div @attributes="@AdditionalAttributes" @ref="@parent" class=@ClassNames.Combine(AdditionalAttributes, "flex flex-row items-center min-w-0 overflow-hidden rounded-sm whitespace-nowrap", Mode.HasFlag(MarqueeMode.Active) || Mode.HasFlag(MarqueeMode.Hover) ? "group" : "") style="--marquee-distance: @(distance)px; --marquee-duration: @(duration.TotalSeconds)s;" @onresizedebounce="@OnResize">
    <div @ref="@target" class=@ClassNames.Combine(["inline-block min-w-0 pointer-events-none", .. DetermineClassNames(Mode, marquee)]) @onresizedebounce="@OnResize">@Text</div>
</div>

@code {

    private double distance;
    private TimeSpan duration = TimeSpan.Zero;
    private MarqueeReference? interop;
    private bool marquee;
    private ElementReference? parent;
    private IList<IAsyncDisposable> resize = [];
    private ElementReference? target;

    [Parameter(CaptureUnmatchedValues = true)]
    public IReadOnlyDictionary<string, object>? AdditionalAttributes { get; init; }

    [Parameter]
    public MarqueeMode Mode { get; init; } = MarqueeMode.Always;

    [Parameter]
    public MarqueeSpeed Speed { get; init; } = MarqueeSpeed.Normal;

    [EditorRequired]
    [Parameter]
    public string Text { get; init; }

    private static IEnumerable<string> DetermineClassNames(MarqueeMode mode, bool marquee)
    {
        if (marquee)
        {
            if (mode.HasFlag(MarqueeMode.Always))
            {
                yield return "animate-marquee";
                yield break;
            }

            if (mode.HasFlag(MarqueeMode.Active))
            {
                yield return "group-active:animate-marquee";
            }

            if (mode.HasFlag(MarqueeMode.Hover))
            {
                yield return "group-hover:animate-marquee";
            }

            yield return "not-group-active:not-group-hover:truncate";
        }
    }

    public async ValueTask DisposeAsync()
    {
        if (interop is not null)
        {
            await interop.DisposeAsync();
            interop = default;
        }

        await Disposer.DisposeAsync(resize);
        resize.Clear();

        target = default;
        parent = default;
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            interop = await Interop.Attach(target!.Value, parent!.Value);
            await Measure();

            resize.Add(await Dom.AddResizeObserver(parent.Value));
            resize.Add(await Dom.AddResizeObserver(target.Value));
        }
    }

    public async Task OnResize() => await Measure();

    private async ValueTask Measure()
    {
        if (interop is null)
        {
            return;
        }

        var measurement = await interop.Measure();
        if (measurement is null)
        {
            return;
        }

        if (marquee != measurement.IsOverflowing)
        {
            if (marquee = measurement.IsOverflowing)
            {
                distance = -(measurement.InnerWidth - measurement.OuterWidth);
                duration = TimeSpan.FromSeconds((Math.Abs(distance) + measurement.OuterWidth) / (byte)Speed);
            }

            StateHasChanged();
        }
    }
}