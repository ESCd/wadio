@using System.Globalization
@using System.Text
@using System.Diagnostics.CodeAnalysis
@using Microsoft.Extensions.ObjectPool

@inherits Stateful<PlayerState>
@implements IAsyncDisposable

@inject IWadioApi Api
@inject PlayerInterop Interop
@inject LocalStorageInterop LocalStorage
@inject ObjectPool<StringBuilder> StringBuilderPool

@if (State.Station is not null)
{
    <PageTitle>Wadio: Listening to @State.Station.Name</PageTitle>
}

<div @attributes="@AdditionalAttributes" class=@ClassNames.Combine(AdditionalAttributes, "backdrop-mantle drop-shadow-sm gap-2.5 grid grid-cols-(--grid-cols-player) md:grid-cols-(--grid-cols-player-md) grid-rows-1 isolate items-center justify-between p-1.5 md:p-2.5 ring-2 ring-fuchsia-800/20 rounded-md shadow-md")>
    <div class="col-1 flex flex-row grow items-center row-1 space-x-4" title="@State.Station?.Name">
        <div class=@ClassNames.Combine("bg-crust ease-in flex items-center justify-center overflow-hidden ring-1 ring-fuchsia-800/20 rounded-sm shadow-sm shrink-0 size-14 transition transition-visibility", State.IsLoading || State.Station is not null ? "opacity-100 visible" : "invisible opacity-0")>
            @if (TryGetArtwork(State, out var artwork))
            {
                <img class="aspect-square object-cover object-center origin-center shrink-0" src="@artwork" loading="eager" />
            }
            else
            {
                <Icon class="opacity-75" Name="@IconName.Radio" Size="@TextSize.ExtraLarge3" />
            }
        </div>

        @if (State.Station is not null)
        {
            <a class="flex flex-col justify-center min-w-0 pr-2.5 w-full" href="/station/@State.Station.Id">
                <Marquee class="font-medium text-lg group-hover:underline hover:underline" Mode="@(MarqueeMode.Active | MarqueeMode.Hover)" Speed="@MarqueeSpeed.Slower" Text="@State.Station.Name" />
                @if (TryFormatMetadata(StringBuilderPool, State.Metadata, out var title))
                {
                    <Marquee class="text-sm" Mode="@(MarqueeMode.Active | MarqueeMode.Hover)" Speed="@MarqueeSpeed.Slow" Text="@title" />
                }
            </a>
        }
        else if (State.IsLoading)
        {
            <Loading Size="@TextSize.ExtraLarge" />
        }
    </div>

    <div class="col-3 md:col-2 flex flex-row grow-0 items-center justify-center row-1">
        <div class=@ClassNames.Combine("aspect-square bg-crust cursor-pointer ease-in flex flex-row items-center justify-center p-2.5 rounded-full ring-1 ring-fuchsia-400/20 shadow-sm transition transition-visibility active:ring-2 active:ring-fuchsia-400/60 focus:ring-2 focus:ring-fuchsia-400/60 focus-visible:ring-2 focus-visible:ring-fuchsia-400/60", State.Station is not null || State.IsLoading ? "opacity-100 visible" : "invisible opacity-0") role="button" title="Stop" @onclick="@OnStopClick" disabled="@(State.Station is null)">
            <Icon Name="@IconName.Stop" Size="@TextSize.ExtraLarge3" />
        </div>
    </div>

    <div class="col-2 md:col-3 flex flex-row items-center justify-end row-1 space-x-2">
        <div class="flex flex-row items-center md:space-x-2">
            <button class="icon" type="button" disabled="@(State.Station is null)" title="Toggle Volume" @onclick="@OnVolumeToggle">
                <Icon Name="@VolumeIcon(State)" Size="@TextSize.ExtraLarge" />
            </button>
            <input class="hidden md:inline-block" type="range" disabled="@(State.Station is null)" min="0" max="1" step="@VolumeStep" value="@State.Volume" @oninput="@OnVolumeInput" @onwheel="@OnVolumeWheel" />
        </div>
    </div>
</div>

@code {

    private const float VolumeStep = 0.01f;

    private StationPlayer? audio;
    private readonly List<IDisposable> subscriptions = [];

    [Parameter(CaptureUnmatchedValues = true)]
    public IReadOnlyDictionary<string, object>? AdditionalAttributes { get; init; }

    [EditorRequired]
    [CascadingParameter]
    public PlayerContext Context { get; init; } = default!;

    protected override void Dispose(bool disposing)
    {
        if (disposing)
        {
            subscriptions.ForEach(subscription => subscription.Dispose());
            subscriptions.Clear();
        }

        base.Dispose(disposing);
    }

    public async ValueTask DisposeAsync()
    {
        if (audio is not null)
        {
            await audio.DisposeAsync();
        }

        Dispose(false);
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            await Mutate(state => PlayerState.Load(LocalStorage, state));
            audio = await Interop.CreatePlayer(State.AsPlayerOptions(), new()
            {
                OnMetaChanged = OnMetaChanged,
                OnStop = () => Context.Update(default),
            });

            subscriptions.Add(Context.OnChanging(OnStationChanging));
            subscriptions.Add(Context.OnChanged(OnStationChanged));
        }
    }

    private async ValueTask OnStationChanged(Station? station)
    {
        if (State.Station?.Id == station?.Id)
        {
            return;
        }

        if (station is not null)
        {
            await Mutate(state => PlayerState.Play(Api.Stations, audio!, station, state));
        }
    }

    private async ValueTask OnStationChanging(Station? station)
    {
        if (State.Station?.Id == station?.Id)
        {
            return;
        }

        if (station is null)
        {
            await Mutate(state => PlayerState.Stop(audio!, state));
        }
    }

    private async Task OnStopClick()
    {
        if (State.Station is null)
        {
            return;
        }

        await Context.Update(default);
    }

    private async ValueTask OnMetaChanged(MediaMetadata? meta) => await Mutate(state => PlayerState.MetaChanged(state, meta));

    private Task OnVolumeInput(ChangeEventArgs e)
    {
        if (BindConverter.TryConvertToFloat(e.Value, CultureInfo.InvariantCulture, out var volume) && State.Volume != volume)
        {
            return Mutate(state => PlayerState.VolumeChanged(LocalStorage, audio!, volume, state));
        }

        return Task.CompletedTask;
    }

    private Task OnVolumeToggle() => Mutate(state => PlayerState.ToggleMute(LocalStorage, audio!, state));

    private Task OnVolumeWheel(WheelEventArgs e)
    {
        if (!e.ShiftKey || e.DeltaY is 0)
        {
            return Task.CompletedTask;
        }

        var volume = (float)Math.Clamp(State.Volume - Math.CopySign(Math.Sqrt(Math.Max(State.Volume, VolumeStep)) / 10, e.DeltaY), 0, 1);
        if (State.Volume != volume)
        {
            return Mutate(state => PlayerState.VolumeChanged(LocalStorage, audio!, volume, state));
        }

        return Task.CompletedTask;
    }

    private static bool TryGetArtwork(PlayerState state, [NotNullWhen(true)] out Uri? url)
    {
        ArgumentNullException.ThrowIfNull(state);

        if (state.IsLoading)
        {
            url = default;
            return false;
        }

        if (state.Metadata?.Artwork.Length is not (null or 0))
        {
            if ((url = state.Metadata.Artwork[0].Url) is not null)
            {
                return true;
            }
        }

        return (url = state.Station?.IconUrl) is not null;
    }

    private static bool TryFormatMetadata(ObjectPool<StringBuilder> builders, MediaMetadata? meta, [NotNullWhen(true)] out string? formatted)
    {
        ArgumentNullException.ThrowIfNull(builders);

        if (string.IsNullOrWhiteSpace(meta?.Title))
        {
            formatted = default;
            return false;
        }

        var builder = builders.Get();
        try
        {
            builder.Append(meta.Title);
            if (!string.IsNullOrEmpty(meta.Artist))
            {
                if (builder.Length > 0)
                {
                    builder.Append(", ");
                }

                builder.Append(meta.Artist);
            }

            formatted = builder.ToString().Trim();
            return !string.IsNullOrEmpty(formatted);
        }
        finally
        {
            builders.Return(builder);
        }
    }

    private static IconName VolumeIcon(PlayerState state)
    {
        ArgumentNullException.ThrowIfNull(state);

        if (state.IsMuted || state.Volume <= 0)
        {
            return IconName.VolumeOff;
        }

        if (state.Volume < .25)
        {
            return IconName.VolumeMute;
        }

        if (state.Volume < .5)
        {
            return IconName.VolumeDown;
        }

        return IconName.VolumeUp;
    }

}